# サーバーサイドエンジニア向け模試環境

模試について：https://www.yumemi.co.jp/serverside_recruit

本レポジトリは上記URLの模試を受験しやすいように、テストケースを用意したものとなります。
実行環境に関しては、各自のPCで構築してください。

# 評価観点

このコーディング試験では、難易度の高い問題に対してどう回答するかのエレガントさは、そこまで重視しません。
基本的に、業務で使われるコードをどう記載していくかが評価ポイントとして高くなります。
弊社の考える業務コードの例としては、例えば以下の特徴を備えているコードとなります。

- 一度書いたコードは本人の手を離れる
- 中長期に渡って使い続けられる可能性がある
- コードのメンテナンス時や、障害発生時に常に仕様書とセットで入手可能とは限らない
- 要求仕様の一部が今後変更される可能性はある
- 通常、プログラムは単体では利用されない
  - 入力されるデータも他のプログラムにより生成される
  - データ形式が将来的に変わる可能性がある

上記を踏まえて例えば『要求仕様中の一文により通常行うべきチェックや例外処理を省略する』ようなケースにおいてはその旨を記載しておく必要があると考えます。

但し、問題文に記載された要求仕様を満たすという前提で、自分はこのコード中で何を重視したかを別途コメントやアピールポイントに記載し、コードがそれを体現していた場合におきましては、 その観点で評価します。

```
例
・この問題文からは使い捨てのコードであると判断し、とにかく実装速度を優先しました。
・実行時のステップ数が少なくなることを最優先としています。
・実行時のメモリ使用量を最小化することを優先しました。
```

# 問題
## 概要
あなたは、あるe-sports大会で集められたゲームのプレイログをもとに、ランキング上位10人を算出することになりました。

このランキングを算出するCLIプログラムの開発をしてください。

## ゲームのプレイログの構造
- プレイログは3列のCSVファイルとして提供されます。
- 1行目は、ヘッダとしてcreate_timestamp,player_id,scoreと記載されています。
- プレイログは2行目以降に記録されており、1行目のヘッダーの各項目に対応したデータが記載されています。
- player_idはゲームにエントリしているプレイヤーごとに一つづつ払い出された個別のIDで、このIDが異なると別のプレイヤーと見做します。
- player_idの構成要素はアルファベットの大文字、小文字、および数字の0-9のみとなります。
- scoreは正の整数となります。
- 同一のプレイヤーが複数回のプレイを実施したときには、複数行のログが記録されます。
- 対象のプレイログ全体は数千万行以上に肥大化することがあります。
- プレイヤーの総数は1万人を超えることはありません。

## ゲームのプレイログサンプル
```
create_timestamp,player_id,score
2021/01/01 12:00,player0001,12345
2021/01/02 13:00,player0002,10000
2021/01/03 12:00,player0021,100
2021/01/04 12:10,player0031,200
2021/01/05 12:00,player0041,300
```

## CLI
結果を標準出力に表示するCLIアプリケーションとして実装してください。

## 入力ルール
- CLIアプリケーションは1つの引数を受け取る
- 上記の引数は処理対象のゲームプレイログを示すファイル名である

## 出力ルール
- 各プレイヤーにおける、全てのプレイの平均点を利用したランキングを算出して、その上位10名を出力してください。
- 出力は3列のCSV形式とする
- 1行目はヘッダとして、rank,player_id,mean_scoreを出力する
- 上記ヘッダに準じて2列目以降を出力する
- rankの項目には平均スコア上位から1,2,3,…の数字が割り当てられる
- 平均スコアは四捨五入で整数で丸められる
- 同点の平均スコアのプレイヤーが居た場合、rankingの数字は同じ数字が割り当てられる
- 同点の平均スコアのプレイヤーが居た場合において、10名以上のランキングが作られる事がある

## 入出力例
```
$ ./get_ranking game_score_log.csv
rank,player_id,mean_score
1,player0001,10000
1,player0002,10000
3,player0003,9000
4,player0004,7000
5,player0005,1000
6,player0006,999
7,player0007,998
8,player0008,997
9,player0009,990
9,player0010,990
9,player0011,990
9,player0012,990
```

# 使い方
## テストの実行
### ① 初期化してください。
```
$ ./envrn.sh init
```

### ② `src/`以下に実行ファイルを作成してください。

example: `src/main.py`

### ③ .env の `EXEC_COMMAND` に実行コマンドを記載してください。

example:
```
EXEC_COMMAND="python3 src/main.py"
```

### ④ テストを実行してください。
```
$ ./envrn.sh test
```

## おまけ
👆 のテストの実行が完了したら、要件の数千万行のケースでの実行時間を検証することも試してみてください。
### ① 5000万行のCSVを生成してください
```
$ ./envrn.sh gen-csv
```

### ② テストを実行してください
```
$ time ./envrn.sh testx
```


# テスト
|  テスト  |  特徴  |  レコード数  |
| ---- | ---- | ---- |
|  test-1  |  通常のケース（サンプルとして公開しているもの）  | 5 |
|  test-2  |  通常のケース  | 10 |
|  test-3  |  通常のケース  | 100 |
|  test-4  |  9位が4人続くケース  | 10000 |
|  test-5  |  レコードが0件のケース（異常終了しないこと）  | 0 |
|  test-x-1  |  レコードが数千万件のケース  | 50000000 |
